// Autogenerated by Thrift Compiler (0.10.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package player

import (
	"bytes"
	"database/sql/driver"
	"errors"
	"fmt"
	"lib/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type Direction int64
const (
  Direction_UP Direction = 1
  Direction_DOWN Direction = 2
  Direction_LEFT Direction = 3
  Direction_RIGHT Direction = 4
)

func (p Direction) String() string {
  switch p {
  case Direction_UP: return "UP"
  case Direction_DOWN: return "DOWN"
  case Direction_LEFT: return "LEFT"
  case Direction_RIGHT: return "RIGHT"
  }
  return "<UNSET>"
}

func DirectionFromString(s string) (Direction, error) {
  switch s {
  case "UP": return Direction_UP, nil 
  case "DOWN": return Direction_DOWN, nil 
  case "LEFT": return Direction_LEFT, nil 
  case "RIGHT": return Direction_RIGHT, nil 
  }
  return Direction(0), fmt.Errorf("not a valid Direction string")
}


func DirectionPtr(v Direction) *Direction { return &v }

func (p Direction) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Direction) UnmarshalText(text []byte) error {
q, err := DirectionFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Direction) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Direction(v)
return nil
}

func (p * Direction) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - X
//  - Y
type Position struct {
  X int32 `thrift:"x,1" db:"x" json:"x"`
  Y int32 `thrift:"y,2" db:"y" json:"y"`
}

func NewPosition() *Position {
  return &Position{}
}


func (p *Position) GetX() int32 {
  return p.X
}

func (p *Position) GetY() int32 {
  return p.Y
}
func (p *Position) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Position)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.X = v
}
  return nil
}

func (p *Position)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Y = v
}
  return nil
}

func (p *Position) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Position"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Position) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("x", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:x: ", p), err) }
  if err := oprot.WriteI32(int32(p.X)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.x (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:x: ", p), err) }
  return err
}

func (p *Position) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("y", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:y: ", p), err) }
  if err := oprot.WriteI32(int32(p.Y)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.y (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:y: ", p), err) }
  return err
}

func (p *Position) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Position(%+v)", *p)
}

// Attributes:
//  - ID
//  - Pos
//  - Dir
//  - Hp
type Tank struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Pos *Position `thrift:"pos,2" db:"pos" json:"pos"`
  Dir Direction `thrift:"dir,3" db:"dir" json:"dir"`
  Hp int32 `thrift:"hp,4" db:"hp" json:"hp"`
}

func NewTank() *Tank {
  return &Tank{}
}


func (p *Tank) GetID() int32 {
  return p.ID
}
var Tank_Pos_DEFAULT *Position
func (p *Tank) GetPos() *Position {
  if !p.IsSetPos() {
    return Tank_Pos_DEFAULT
  }
return p.Pos
}

func (p *Tank) GetDir() Direction {
  return p.Dir
}

func (p *Tank) GetHp() int32 {
  return p.Hp
}
func (p *Tank) IsSetPos() bool {
  return p.Pos != nil
}

func (p *Tank) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Tank)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *Tank)  ReadField2(iprot thrift.TProtocol) error {
  p.Pos = &Position{}
  if err := p.Pos.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Pos), err)
  }
  return nil
}

func (p *Tank)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Direction(v)
  p.Dir = temp
}
  return nil
}

func (p *Tank)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Hp = v
}
  return nil
}

func (p *Tank) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Tank"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Tank) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *Tank) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("pos", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pos: ", p), err) }
  if err := p.Pos.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Pos), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pos: ", p), err) }
  return err
}

func (p *Tank) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("dir", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dir: ", p), err) }
  if err := oprot.WriteI32(int32(p.Dir)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dir (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dir: ", p), err) }
  return err
}

func (p *Tank) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("hp", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:hp: ", p), err) }
  if err := oprot.WriteI32(int32(p.Hp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hp (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:hp: ", p), err) }
  return err
}

func (p *Tank) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Tank(%+v)", *p)
}

// Attributes:
//  - ID
//  - Pos
//  - Dir
type Shell struct {
  ID int32 `thrift:"id,1" db:"id" json:"id"`
  Pos *Position `thrift:"pos,2" db:"pos" json:"pos"`
  Dir Direction `thrift:"dir,3" db:"dir" json:"dir"`
}

func NewShell() *Shell {
  return &Shell{}
}


func (p *Shell) GetID() int32 {
  return p.ID
}
var Shell_Pos_DEFAULT *Position
func (p *Shell) GetPos() *Position {
  if !p.IsSetPos() {
    return Shell_Pos_DEFAULT
  }
return p.Pos
}

func (p *Shell) GetDir() Direction {
  return p.Dir
}
func (p *Shell) IsSetPos() bool {
  return p.Pos != nil
}

func (p *Shell) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Shell)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *Shell)  ReadField2(iprot thrift.TProtocol) error {
  p.Pos = &Position{}
  if err := p.Pos.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Pos), err)
  }
  return nil
}

func (p *Shell)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Direction(v)
  p.Dir = temp
}
  return nil
}

func (p *Shell) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Shell"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Shell) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI32(int32(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *Shell) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("pos", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pos: ", p), err) }
  if err := p.Pos.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Pos), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pos: ", p), err) }
  return err
}

func (p *Shell) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("dir", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dir: ", p), err) }
  if err := oprot.WriteI32(int32(p.Dir)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dir (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dir: ", p), err) }
  return err
}

func (p *Shell) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Shell(%+v)", *p)
}

// Attributes:
//  - Tanks
//  - Shells
//  - YourFlags
//  - EnemyFlags
type GameState struct {
  Tanks []*Tank `thrift:"tanks,1" db:"tanks" json:"tanks"`
  Shells []*Shell `thrift:"shells,2" db:"shells" json:"shells"`
  YourFlags int32 `thrift:"yourFlags,3" db:"yourFlags" json:"yourFlags"`
  EnemyFlags int32 `thrift:"enemyFlags,4" db:"enemyFlags" json:"enemyFlags"`
}

func NewGameState() *GameState {
  return &GameState{}
}


func (p *GameState) GetTanks() []*Tank {
  return p.Tanks
}

func (p *GameState) GetShells() []*Shell {
  return p.Shells
}

func (p *GameState) GetYourFlags() int32 {
  return p.YourFlags
}

func (p *GameState) GetEnemyFlags() int32 {
  return p.EnemyFlags
}
func (p *GameState) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GameState)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tank, 0, size)
  p.Tanks =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &Tank{}
    if err := _elem0.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Tanks = append(p.Tanks, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *GameState)  ReadField2(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Shell, 0, size)
  p.Shells =  tSlice
  for i := 0; i < size; i ++ {
    _elem1 := &Shell{}
    if err := _elem1.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
    }
    p.Shells = append(p.Shells, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *GameState)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.YourFlags = v
}
  return nil
}

func (p *GameState)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.EnemyFlags = v
}
  return nil
}

func (p *GameState) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("GameState"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GameState) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tanks", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tanks: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tanks)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tanks {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tanks: ", p), err) }
  return err
}

func (p *GameState) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("shells", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:shells: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Shells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Shells {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:shells: ", p), err) }
  return err
}

func (p *GameState) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("yourFlags", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:yourFlags: ", p), err) }
  if err := oprot.WriteI32(int32(p.YourFlags)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.yourFlags (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:yourFlags: ", p), err) }
  return err
}

func (p *GameState) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("enemyFlags", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:enemyFlags: ", p), err) }
  if err := oprot.WriteI32(int32(p.EnemyFlags)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.enemyFlags (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:enemyFlags: ", p), err) }
  return err
}

func (p *GameState) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GameState(%+v)", *p)
}

// Attributes:
//  - TankId: DO NOT try to send a order with competitor's tank id.
// In that case, game engine will treat it as cheat and would ignore ALL this player's orders in this round.
// 
//  - Order: Possible orders are: turnTo, fire, move. All others words are illegal and will be ignored.
// If want a tank to stick around, just do NOT send any order with that tank.
// 
//  - Dir: the dir are always on base of the map instead of the tank itself,
// which mean if a 'fire' order with UP direction will made the tank fire a shell toward the UP diction of the map.
// 
// Only move order does not need a direction, in that case just give a direction and game engine will ignore it.
// 
type Order struct {
  TankId int32 `thrift:"tankId,1" db:"tankId" json:"tankId"`
  Order string `thrift:"order,2" db:"order" json:"order"`
  Dir Direction `thrift:"dir,3" db:"dir" json:"dir"`
}

func NewOrder() *Order {
  return &Order{}
}


func (p *Order) GetTankId() int32 {
  return p.TankId
}

func (p *Order) GetOrder() string {
  return p.Order
}

func (p *Order) GetDir() Direction {
  return p.Dir
}
func (p *Order) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Order)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TankId = v
}
  return nil
}

func (p *Order)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Order = v
}
  return nil
}

func (p *Order)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Direction(v)
  p.Dir = temp
}
  return nil
}

func (p *Order) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Order"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Order) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tankId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tankId: ", p), err) }
  if err := oprot.WriteI32(int32(p.TankId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tankId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tankId: ", p), err) }
  return err
}

func (p *Order) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("order", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:order: ", p), err) }
  if err := oprot.WriteString(string(p.Order)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.order (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:order: ", p), err) }
  return err
}

func (p *Order) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("dir", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:dir: ", p), err) }
  if err := oprot.WriteI32(int32(p.Dir)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.dir (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:dir: ", p), err) }
  return err
}

func (p *Order) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Order(%+v)", *p)
}

// Attributes:
//  - TankSpeed
//  - ShellSpeed
//  - TankHP
//  - TankScore
//  - FlagScore
//  - MaxRound
//  - RoundTimeoutInMs
type Args_ struct {
  TankSpeed int32 `thrift:"tankSpeed,1" db:"tankSpeed" json:"tankSpeed"`
  ShellSpeed int32 `thrift:"shellSpeed,2" db:"shellSpeed" json:"shellSpeed"`
  TankHP int32 `thrift:"tankHP,3" db:"tankHP" json:"tankHP"`
  TankScore int32 `thrift:"tankScore,4" db:"tankScore" json:"tankScore"`
  FlagScore int32 `thrift:"flagScore,5" db:"flagScore" json:"flagScore"`
  MaxRound int32 `thrift:"maxRound,6" db:"maxRound" json:"maxRound"`
  RoundTimeoutInMs int32 `thrift:"roundTimeoutInMs,7" db:"roundTimeoutInMs" json:"roundTimeoutInMs"`
}

func NewArgs_() *Args_ {
  return &Args_{}
}


func (p *Args_) GetTankSpeed() int32 {
  return p.TankSpeed
}

func (p *Args_) GetShellSpeed() int32 {
  return p.ShellSpeed
}

func (p *Args_) GetTankHP() int32 {
  return p.TankHP
}

func (p *Args_) GetTankScore() int32 {
  return p.TankScore
}

func (p *Args_) GetFlagScore() int32 {
  return p.FlagScore
}

func (p *Args_) GetMaxRound() int32 {
  return p.MaxRound
}

func (p *Args_) GetRoundTimeoutInMs() int32 {
  return p.RoundTimeoutInMs
}
func (p *Args_) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    case 4:
      if err := p.ReadField4(iprot); err != nil {
        return err
      }
    case 5:
      if err := p.ReadField5(iprot); err != nil {
        return err
      }
    case 6:
      if err := p.ReadField6(iprot); err != nil {
        return err
      }
    case 7:
      if err := p.ReadField7(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Args_)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TankSpeed = v
}
  return nil
}

func (p *Args_)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ShellSpeed = v
}
  return nil
}

func (p *Args_)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TankHP = v
}
  return nil
}

func (p *Args_)  ReadField4(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TankScore = v
}
  return nil
}

func (p *Args_)  ReadField5(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.FlagScore = v
}
  return nil
}

func (p *Args_)  ReadField6(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.MaxRound = v
}
  return nil
}

func (p *Args_)  ReadField7(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.RoundTimeoutInMs = v
}
  return nil
}

func (p *Args_) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("Args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
    if err := p.writeField4(oprot); err != nil { return err }
    if err := p.writeField5(oprot); err != nil { return err }
    if err := p.writeField6(oprot); err != nil { return err }
    if err := p.writeField7(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Args_) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tankSpeed", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tankSpeed: ", p), err) }
  if err := oprot.WriteI32(int32(p.TankSpeed)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tankSpeed (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tankSpeed: ", p), err) }
  return err
}

func (p *Args_) writeField2(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("shellSpeed", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:shellSpeed: ", p), err) }
  if err := oprot.WriteI32(int32(p.ShellSpeed)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.shellSpeed (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:shellSpeed: ", p), err) }
  return err
}

func (p *Args_) writeField3(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tankHP", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tankHP: ", p), err) }
  if err := oprot.WriteI32(int32(p.TankHP)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tankHP (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tankHP: ", p), err) }
  return err
}

func (p *Args_) writeField4(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tankScore", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:tankScore: ", p), err) }
  if err := oprot.WriteI32(int32(p.TankScore)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tankScore (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:tankScore: ", p), err) }
  return err
}

func (p *Args_) writeField5(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("flagScore", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:flagScore: ", p), err) }
  if err := oprot.WriteI32(int32(p.FlagScore)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.flagScore (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:flagScore: ", p), err) }
  return err
}

func (p *Args_) writeField6(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("maxRound", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:maxRound: ", p), err) }
  if err := oprot.WriteI32(int32(p.MaxRound)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxRound (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:maxRound: ", p), err) }
  return err
}

func (p *Args_) writeField7(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("roundTimeoutInMs", thrift.I32, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:roundTimeoutInMs: ", p), err) }
  if err := oprot.WriteI32(int32(p.RoundTimeoutInMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.roundTimeoutInMs (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:roundTimeoutInMs: ", p), err) }
  return err
}

func (p *Args_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Args_(%+v)", *p)
}

type PlayerServer interface {
  // Upload the map to player.
  // The map is made of two-dimesional array of integer. The first dimension means row of the map. The second dimension means column of the map.
  // For example, if N is the map size, position(0,0) means upper left corner, position(0,N) means the upper right corner.
  // In the map array, 0 means empty field, 1 means barrier, 2 means woods, 3 means flag.
  // 
  // 
  // Parameters:
  //  - Gamemap
  UploadMap(gamemap [][]int32) (err error)
  // Parameters:
  //  - Arguments
  UploadParamters(arguments *Args_) (err error)
  // Assign a list of tank id to the player.
  // each player may have more than one tank, so the parameter is a list.
  // 
  // 
  // Parameters:
  //  - Tanks
  AssignTanks(tanks []int32) (err error)
  // Report latest game state to player.
  // 
  // 
  // Parameters:
  //  - State
  LatestState(state *GameState) (err error)
  // Ask for the tank orders for this round.
  // If this funtion does not return orders within the given round timeout, game engine will make all this player's tank to stick around.
  GetNewOrders() (r []*Order, err error)
}

type PlayerServerClient struct {
  Transport thrift.TTransport
  ProtocolFactory thrift.TProtocolFactory
  InputProtocol thrift.TProtocol
  OutputProtocol thrift.TProtocol
  SeqId int32
}

func NewPlayerServerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *PlayerServerClient {
  return &PlayerServerClient{Transport: t,
    ProtocolFactory: f,
    InputProtocol: f.GetProtocol(t),
    OutputProtocol: f.GetProtocol(t),
    SeqId: 0,
  }
}

func NewPlayerServerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *PlayerServerClient {
  return &PlayerServerClient{Transport: t,
    ProtocolFactory: nil,
    InputProtocol: iprot,
    OutputProtocol: oprot,
    SeqId: 0,
  }
}

// Upload the map to player.
// The map is made of two-dimesional array of integer. The first dimension means row of the map. The second dimension means column of the map.
// For example, if N is the map size, position(0,0) means upper left corner, position(0,N) means the upper right corner.
// In the map array, 0 means empty field, 1 means barrier, 2 means woods, 3 means flag.
// 
// 
// Parameters:
//  - Gamemap
func (p *PlayerServerClient) UploadMap(gamemap [][]int32) (err error) {
  if err = p.sendUploadMap(gamemap); err != nil { return }
  return p.recvUploadMap()
}

func (p *PlayerServerClient) sendUploadMap(gamemap [][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("uploadMap", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := PlayerServerUploadMapArgs{
  Gamemap : gamemap,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *PlayerServerClient) recvUploadMap() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "uploadMap" {
    err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "uploadMap failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "uploadMap failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error2 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error3 error
    error3, err = error2.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error3
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "uploadMap failed: invalid message type")
    return
  }
  result := PlayerServerUploadMapResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Arguments
func (p *PlayerServerClient) UploadParamters(arguments *Args_) (err error) {
  if err = p.sendUploadParamters(arguments); err != nil { return }
  return p.recvUploadParamters()
}

func (p *PlayerServerClient) sendUploadParamters(arguments *Args_)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("uploadParamters", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := PlayerServerUploadParamtersArgs{
  Arguments : arguments,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *PlayerServerClient) recvUploadParamters() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "uploadParamters" {
    err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "uploadParamters failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "uploadParamters failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error4 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error5 error
    error5, err = error4.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error5
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "uploadParamters failed: invalid message type")
    return
  }
  result := PlayerServerUploadParamtersResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Assign a list of tank id to the player.
// each player may have more than one tank, so the parameter is a list.
// 
// 
// Parameters:
//  - Tanks
func (p *PlayerServerClient) AssignTanks(tanks []int32) (err error) {
  if err = p.sendAssignTanks(tanks); err != nil { return }
  return p.recvAssignTanks()
}

func (p *PlayerServerClient) sendAssignTanks(tanks []int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("assignTanks", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := PlayerServerAssignTanksArgs{
  Tanks : tanks,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *PlayerServerClient) recvAssignTanks() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "assignTanks" {
    err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "assignTanks failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "assignTanks failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error6 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error7 error
    error7, err = error6.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error7
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "assignTanks failed: invalid message type")
    return
  }
  result := PlayerServerAssignTanksResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Report latest game state to player.
// 
// 
// Parameters:
//  - State
func (p *PlayerServerClient) LatestState(state *GameState) (err error) {
  if err = p.sendLatestState(state); err != nil { return }
  return p.recvLatestState()
}

func (p *PlayerServerClient) sendLatestState(state *GameState)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("latestState", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := PlayerServerLatestStateArgs{
  State : state,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *PlayerServerClient) recvLatestState() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "latestState" {
    err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "latestState failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "latestState failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error8 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error9 error
    error9, err = error8.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error9
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "latestState failed: invalid message type")
    return
  }
  result := PlayerServerLatestStateResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Ask for the tank orders for this round.
// If this funtion does not return orders within the given round timeout, game engine will make all this player's tank to stick around.
func (p *PlayerServerClient) GetNewOrders() (r []*Order, err error) {
  if err = p.sendGetNewOrders(); err != nil { return }
  return p.recvGetNewOrders()
}

func (p *PlayerServerClient) sendGetNewOrders()(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("getNewOrders", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := PlayerServerGetNewOrdersArgs{
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *PlayerServerClient) recvGetNewOrders() (value []*Order, err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "getNewOrders" {
    err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getNewOrders failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getNewOrders failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error10 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error11 error
    error11, err = error10.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error11
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getNewOrders failed: invalid message type")
    return
  }
  result := PlayerServerGetNewOrdersResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  value = result.GetSuccess()
  return
}


type PlayerServerProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler PlayerServer
}

func (p *PlayerServerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *PlayerServerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *PlayerServerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewPlayerServerProcessor(handler PlayerServer) *PlayerServerProcessor {

  self12 := &PlayerServerProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self12.processorMap["uploadMap"] = &playerServerProcessorUploadMap{handler:handler}
  self12.processorMap["uploadParamters"] = &playerServerProcessorUploadParamters{handler:handler}
  self12.processorMap["assignTanks"] = &playerServerProcessorAssignTanks{handler:handler}
  self12.processorMap["latestState"] = &playerServerProcessorLatestState{handler:handler}
  self12.processorMap["getNewOrders"] = &playerServerProcessorGetNewOrders{handler:handler}
return self12
}

func (p *PlayerServerProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err := iprot.ReadMessageBegin()
  if err != nil { return false, err }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(seqId, iprot, oprot)
  }
  iprot.Skip(thrift.STRUCT)
  iprot.ReadMessageEnd()
  x13 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
  x13.Write(oprot)
  oprot.WriteMessageEnd()
  oprot.Flush()
  return false, x13

}

type playerServerProcessorUploadMap struct {
  handler PlayerServer
}

func (p *playerServerProcessorUploadMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PlayerServerUploadMapArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("uploadMap", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := PlayerServerUploadMapResult{}
  var err2 error
  if err2 = p.handler.UploadMap(args.Gamemap); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing uploadMap: " + err2.Error())
    oprot.WriteMessageBegin("uploadMap", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  if err2 = oprot.WriteMessageBegin("uploadMap", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type playerServerProcessorUploadParamters struct {
  handler PlayerServer
}

func (p *playerServerProcessorUploadParamters) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PlayerServerUploadParamtersArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("uploadParamters", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := PlayerServerUploadParamtersResult{}
  var err2 error
  if err2 = p.handler.UploadParamters(args.Arguments); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing uploadParamters: " + err2.Error())
    oprot.WriteMessageBegin("uploadParamters", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  if err2 = oprot.WriteMessageBegin("uploadParamters", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type playerServerProcessorAssignTanks struct {
  handler PlayerServer
}

func (p *playerServerProcessorAssignTanks) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PlayerServerAssignTanksArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("assignTanks", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := PlayerServerAssignTanksResult{}
  var err2 error
  if err2 = p.handler.AssignTanks(args.Tanks); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing assignTanks: " + err2.Error())
    oprot.WriteMessageBegin("assignTanks", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  if err2 = oprot.WriteMessageBegin("assignTanks", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type playerServerProcessorLatestState struct {
  handler PlayerServer
}

func (p *playerServerProcessorLatestState) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PlayerServerLatestStateArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("latestState", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := PlayerServerLatestStateResult{}
  var err2 error
  if err2 = p.handler.LatestState(args.State); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing latestState: " + err2.Error())
    oprot.WriteMessageBegin("latestState", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  }
  if err2 = oprot.WriteMessageBegin("latestState", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}

type playerServerProcessorGetNewOrders struct {
  handler PlayerServer
}

func (p *playerServerProcessorGetNewOrders) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := PlayerServerGetNewOrdersArgs{}
  if err = args.Read(iprot); err != nil {
    iprot.ReadMessageEnd()
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
    oprot.WriteMessageBegin("getNewOrders", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return false, err
  }

  iprot.ReadMessageEnd()
  result := PlayerServerGetNewOrdersResult{}
var retval []*Order
  var err2 error
  if retval, err2 = p.handler.GetNewOrders(); err2 != nil {
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNewOrders: " + err2.Error())
    oprot.WriteMessageBegin("getNewOrders", thrift.EXCEPTION, seqId)
    x.Write(oprot)
    oprot.WriteMessageEnd()
    oprot.Flush()
    return true, err2
  } else {
    result.Success = retval
}
  if err2 = oprot.WriteMessageBegin("getNewOrders", thrift.REPLY, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Gamemap
type PlayerServerUploadMapArgs struct {
  Gamemap [][]int32 `thrift:"gamemap,1" db:"gamemap" json:"gamemap"`
}

func NewPlayerServerUploadMapArgs() *PlayerServerUploadMapArgs {
  return &PlayerServerUploadMapArgs{}
}


func (p *PlayerServerUploadMapArgs) GetGamemap() [][]int32 {
  return p.Gamemap
}
func (p *PlayerServerUploadMapArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerUploadMapArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]int32, 0, size)
  p.Gamemap =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]int32, 0, size)
    _elem14 :=  tSlice
    for i := 0; i < size; i ++ {
var _elem15 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem15 = v
}
      _elem14 = append(_elem14, _elem15)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Gamemap = append(p.Gamemap, _elem14)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PlayerServerUploadMapArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("uploadMap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerUploadMapArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("gamemap", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:gamemap: ", p), err) }
  if err := oprot.WriteListBegin(thrift.LIST, len(p.Gamemap)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Gamemap {
    if err := oprot.WriteListBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:gamemap: ", p), err) }
  return err
}

func (p *PlayerServerUploadMapArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerUploadMapArgs(%+v)", *p)
}

type PlayerServerUploadMapResult struct {
}

func NewPlayerServerUploadMapResult() *PlayerServerUploadMapResult {
  return &PlayerServerUploadMapResult{}
}

func (p *PlayerServerUploadMapResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerUploadMapResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("uploadMap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerUploadMapResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerUploadMapResult(%+v)", *p)
}

// Attributes:
//  - Arguments
type PlayerServerUploadParamtersArgs struct {
  Arguments *Args_ `thrift:"arguments,1" db:"arguments" json:"arguments"`
}

func NewPlayerServerUploadParamtersArgs() *PlayerServerUploadParamtersArgs {
  return &PlayerServerUploadParamtersArgs{}
}

var PlayerServerUploadParamtersArgs_Arguments_DEFAULT *Args_
func (p *PlayerServerUploadParamtersArgs) GetArguments() *Args_ {
  if !p.IsSetArguments() {
    return PlayerServerUploadParamtersArgs_Arguments_DEFAULT
  }
return p.Arguments
}
func (p *PlayerServerUploadParamtersArgs) IsSetArguments() bool {
  return p.Arguments != nil
}

func (p *PlayerServerUploadParamtersArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerUploadParamtersArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.Arguments = &Args_{}
  if err := p.Arguments.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Arguments), err)
  }
  return nil
}

func (p *PlayerServerUploadParamtersArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("uploadParamters_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerUploadParamtersArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("arguments", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:arguments: ", p), err) }
  if err := p.Arguments.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Arguments), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:arguments: ", p), err) }
  return err
}

func (p *PlayerServerUploadParamtersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerUploadParamtersArgs(%+v)", *p)
}

type PlayerServerUploadParamtersResult struct {
}

func NewPlayerServerUploadParamtersResult() *PlayerServerUploadParamtersResult {
  return &PlayerServerUploadParamtersResult{}
}

func (p *PlayerServerUploadParamtersResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerUploadParamtersResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("uploadParamters_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerUploadParamtersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerUploadParamtersResult(%+v)", *p)
}

// Attributes:
//  - Tanks
type PlayerServerAssignTanksArgs struct {
  Tanks []int32 `thrift:"tanks,1" db:"tanks" json:"tanks"`
}

func NewPlayerServerAssignTanksArgs() *PlayerServerAssignTanksArgs {
  return &PlayerServerAssignTanksArgs{}
}


func (p *PlayerServerAssignTanksArgs) GetTanks() []int32 {
  return p.Tanks
}
func (p *PlayerServerAssignTanksArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerAssignTanksArgs)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.Tanks =  tSlice
  for i := 0; i < size; i ++ {
var _elem16 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem16 = v
}
    p.Tanks = append(p.Tanks, _elem16)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PlayerServerAssignTanksArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("assignTanks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerAssignTanksArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("tanks", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tanks: ", p), err) }
  if err := oprot.WriteListBegin(thrift.I32, len(p.Tanks)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tanks {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tanks: ", p), err) }
  return err
}

func (p *PlayerServerAssignTanksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerAssignTanksArgs(%+v)", *p)
}

type PlayerServerAssignTanksResult struct {
}

func NewPlayerServerAssignTanksResult() *PlayerServerAssignTanksResult {
  return &PlayerServerAssignTanksResult{}
}

func (p *PlayerServerAssignTanksResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerAssignTanksResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("assignTanks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerAssignTanksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerAssignTanksResult(%+v)", *p)
}

// Attributes:
//  - State
type PlayerServerLatestStateArgs struct {
  State *GameState `thrift:"state,1" db:"state" json:"state"`
}

func NewPlayerServerLatestStateArgs() *PlayerServerLatestStateArgs {
  return &PlayerServerLatestStateArgs{}
}

var PlayerServerLatestStateArgs_State_DEFAULT *GameState
func (p *PlayerServerLatestStateArgs) GetState() *GameState {
  if !p.IsSetState() {
    return PlayerServerLatestStateArgs_State_DEFAULT
  }
return p.State
}
func (p *PlayerServerLatestStateArgs) IsSetState() bool {
  return p.State != nil
}

func (p *PlayerServerLatestStateArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerLatestStateArgs)  ReadField1(iprot thrift.TProtocol) error {
  p.State = &GameState{}
  if err := p.State.Read(iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.State), err)
  }
  return nil
}

func (p *PlayerServerLatestStateArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("latestState_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerLatestStateArgs) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("state", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:state: ", p), err) }
  if err := p.State.Write(oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.State), err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:state: ", p), err) }
  return err
}

func (p *PlayerServerLatestStateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerLatestStateArgs(%+v)", *p)
}

type PlayerServerLatestStateResult struct {
}

func NewPlayerServerLatestStateResult() *PlayerServerLatestStateResult {
  return &PlayerServerLatestStateResult{}
}

func (p *PlayerServerLatestStateResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerLatestStateResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("latestState_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerLatestStateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerLatestStateResult(%+v)", *p)
}

type PlayerServerGetNewOrdersArgs struct {
}

func NewPlayerServerGetNewOrdersArgs() *PlayerServerGetNewOrdersArgs {
  return &PlayerServerGetNewOrdersArgs{}
}

func (p *PlayerServerGetNewOrdersArgs) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerGetNewOrdersArgs) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("getNewOrders_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerGetNewOrdersArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerGetNewOrdersArgs(%+v)", *p)
}

// Attributes:
//  - Success
type PlayerServerGetNewOrdersResult struct {
  Success []*Order `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewPlayerServerGetNewOrdersResult() *PlayerServerGetNewOrdersResult {
  return &PlayerServerGetNewOrdersResult{}
}

var PlayerServerGetNewOrdersResult_Success_DEFAULT []*Order

func (p *PlayerServerGetNewOrdersResult) GetSuccess() []*Order {
  return p.Success
}
func (p *PlayerServerGetNewOrdersResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *PlayerServerGetNewOrdersResult) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if err := p.ReadField0(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PlayerServerGetNewOrdersResult)  ReadField0(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Order, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem17 := &Order{}
    if err := _elem17.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem17), err)
    }
    p.Success = append(p.Success, _elem17)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *PlayerServerGetNewOrdersResult) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("getNewOrders_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PlayerServerGetNewOrdersResult) writeField0(oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *PlayerServerGetNewOrdersResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PlayerServerGetNewOrdersResult(%+v)", *p)
}


